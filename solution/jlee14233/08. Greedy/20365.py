##블로그 2
'''
neighbor 블로그를 운영하는 일우는 매일 아침 풀고 싶은 문제를 미리 정해놓고 글을 올린다. 그리고 매일 밤 각각의 문제에 대하여, 해결한 경우 파란색, 해결하지 못한 경우 빨간색으로 칠한다. 일우는 각 문제를 칠할 때 아래와 같은 과정을 한 번의 작업으로 수행한다.

연속된 임의의 문제들을 선택한다.
선택된 문제들을 전부 원하는 같은 색으로 칠한다.

예를 들어, 각 문제를 위와 같은 색으로 칠하려고 할 때, 1~2번 문제를 파란색, 3번을 빨간색, 4번을 파란색, 5번을 빨간색, 6~7번을 파란색, 8번을 빨간색으로 칠하는 작업을 순서대로 수행하면 6번의 작업을 거쳐야 한다. 하지만, 1~7번 문제를 파란색, 3번을 빨간색, 5번을 빨간색, 8번을 빨간색으로 순서대로 칠한다면 작업 횟수는 4번으로 가장 적다.

일우는 매일 500,000문제까지 시도하기 때문에, 이 작업이 꽤나 귀찮아지기 시작했다. 그래서 가장 효율적인 방법으로 위 작업을 수행하기를 원한다. 일우를 도와 각 문제를 주어진 색으로 칠할 때 필요한 최소한의 작업 횟수를 구하는 프로그램을 작성하라.

입력
첫째 줄에 색을 칠해야 하는 문제의 수 N (1 ≤ N ≤ 500,000)이 주어진다.

둘째 줄에 N개의 문자가 공백 없이 순서대로 주어진다. 각 문자는 i번째 문제를 어떤 색으로 칠해야 하는지를 의미하며, R은 빨간색, B는 파란색을 나타낸다. 그 외에 다른 문자는 주어지지 않는다.

출력
첫째 줄에 일우가 주어진 모든 문제를 원하는 색으로 칠할 때까지 필요한 작업 횟수의 최솟값을 출력하라.
'''

'''
문자열을 정렬해서 가운데에 있는 값이 b인지 r인지 구분한다.

'''

import sys
from collections import deque

sys.stdin = open('solution/jlee14233/08. Greedy/입력.txt', 'r')

n=int(sys.stdin.readline())
string=str(sys.stdin.readline().strip())

while True:
    if 'BB' in string:
        string = string.replace('BB','B')
    elif 'RR' in string:
        string = string.replace('RR','R')
    else:
        break

print(len(string)//2+1)

'''
아이디어:
결국 반복적으로 나오는 것들은 하나로 묶는다
그리고 전체의 문자열 길이의 절반 이 중간중간 섞어주어야하는 횟수이다
BBBBrrrBBBrrrBrBr  == B,r,B,r,B,r,B,r 
과 동일하다는 것을 알 수 있다.
전체를 동일하게 칠한 다음에 반복되는 r의 갯수를 세어주면 끝

처음에는 짝수개와 홀수개를 나눠서 생각했는데, 이 또한 결국 동일해서
마지막에 print(len(string)//2+1)으로 출력하면 된다.

'''